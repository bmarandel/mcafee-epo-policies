# -*- coding: utf-8 -*-
################################################################################
# Copyright (c) 2019 Benjamin Marandel - All Rights Reserved.
################################################################################

"""
This module defines the class ESTPPolicyExploitPrevention.
"""

import uuid
import base64 as b64
import datetime as dt
import xml.etree.ElementTree as et
from ...policies import Policy

#class SearchFilter():
#    """
#    The SearchFilter class can be used to define a search filter to pass as an argument
#    to many ESTPPolicyExploitPrevention methods.
#    """
#
#    def __init__(self):

class ESTPPolicyExploitPrevention(Policy):
    """
    The ESTPPolicyExploitPrevention class can be used to edit the Endpoint Security
    Threat Prevention policy: Exploit Prevention.
    """

    def __init__(self, policy_from_estppolicies=None):
        super(ESTPPolicyExploitPrevention, self).__init__(policy_from_estppolicies)
        self.main = ''
        self.eprules = dict()
        self.signatures = dict()
        self.aprules = dict()
        self.exclusions = dict()
        self.lirules = dict()
        if policy_from_estppolicies is not None:
            if self.get_type() != 'EAM_BufferOverflow_Policies':
                raise ValueError('Wrong policy! Policy type must be "EAM_BufferOverflow_Policies".')
            else:
                self.load_policy()

    def __repr__(self):
        return 'ESTPPolicyExploitPrevention()'

    def load_from_file(self, file_path):
        super(ESTPPolicyExploitPrevention, self).load_from_file(file_path)
        if self.root is not None:
            if self.get_type() != 'EAM_BufferOverflow_Policies':
                raise ValueError('Wrong policy! Policy type must be "EAM_BufferOverflow_Policies".')
            else:
                self.load_policy()

    def load_policy(self):
        policy_obj = self.root.find('EPOPolicyObject')
        for policy_ref in policy_obj.findall('PolicySettings'):
            policy_set = self.root.find('./EPOPolicySettings[@name="{}"]'.format(policy_ref.text))
            section = policy_set.find('Section').attrib['name']
            if section == 'EXPRule':
                self.__load_signature(policy_set)
            elif section == 'EXPAPRule':
                self.__load_aprule(policy_set)
            elif section == 'EXPExpertRule':
                self.__load_eprule(policy_set)
            elif section == 'bopExclItems':
                self.__load_exclusion(policy_set)
            elif section == 'EXPLinuxRule':
                self.__load_lirule(policy_set)
            else:
                raise ValueError('Unknown section value type in policy:{}'.format(section))
        return True

    def __load_signature(self, policy_setting):
        set_key = policy_setting.attrib['name']
        section_obj = policy_setting.find('Section[@name="EXPRule"]')
        sig_props = dict()
        prop_keys = section_obj.findall('Setting')
        for prop in prop_keys:
            sig_props[prop.get('name')] = prop.get('value')
        self.signatures[set_key] = sig_props

    def __load_aprule(self, policy_setting):
        set_key = policy_setting.attrib['name']
        self.aprules[set_key] = 'TBI'
        #print('Load Application Rule -> TBI')

    def __load_eprule(self, policy_setting):
        set_key = policy_setting.attrib['name']
        section_obj = policy_setting.find('Section[@name="EXPExpertRule"]')
        ep_props = dict()
        prop_keys = section_obj.findall('Setting')
        for prop in prop_keys:
            ep_props[prop.get('name')] = prop.get('value')
        self.eprules[set_key] = ep_props

    def __load_exclusion(self, policy_setting):
        self.main = policy_setting.attrib['name']
        print('Main ref: {}'.format(self.main))
        print('Load Exclusion -> TBI')

    def __load_lirule(self, policy_setting):
        set_key = policy_setting.attrib['name']
        section_obj = policy_setting.find('Section[@name="EXPLinuxRule"]')
        sig_props = dict()
        prop_keys = section_obj.findall('Setting')
        for prop in prop_keys:
            sig_props[prop.get('name')] = prop.get('value')
        self.lirules[set_key] = sig_props

    def __get_signature(self, setting, value):
        search = [row for row in self.signatures if self.signatures[row][setting] == value]
        return search[0] if len(search) >= 1 else None

    def __get_eprule(self, setting, value):
        search = [row for row in self.eprules if self.eprules[row][setting] == value]
        return search[0] if len(search) >= 1 else None

    def __get_signature_id(self):
        int_id = 20000
        if len(self.eprules) > 0:
            ids = [int(self.eprules[row]['SignatureID']) for row in self.eprules]
            for x in sorted(ids):
                if x == int_id:
                    int_id += 1
        return str(int_id)

    def print_info(self):
        """
        Print information about the current loaded policy object.
        """
        print('Policy {} has {} signatures, {} application rules and {} exclusions. ({})'.format(
              self.get_name(), len(self.signatures) + len(self.eprules) + len(self.lirules), len(self.aprules), len(self.exclusions), self.__get_signature_id()))

# The module settings are stored in a Section called "bopStatus"
# <Setting name="bopLevel" value="0" />
# <Setting name="bopReportEnabled" value="1" />

    # ------------------------------ Exploit Prevention Policy ------------------------------
    # Exploit Prevention:
    #   Enable Exploit Prevention
    def get_exploit_prevention(self):
        """
        Get the Exploit Prevention module state
        """
        return self.get_policy_setting_value(self.main, 'bopStatus', 'bopEnabled')

    def set_exploit_prevention(self, state):
        """
        Set the Exploit Prevention module state
        """
        return self.set_policy_setting_value(self.main, 'bopStatus', 'bopEnabled', state)

    exploit_prevention = property(get_exploit_prevention, set_exploit_prevention)

    # ------------------------------ Exploit Prevention Policy ------------------------------
    # Generic Privilege Escalation Prevention:
    #   Enable Generic Privilege Escalation Prevention
    def get_gpep(self):
        """
        Get the Generic Priviledge Escalation Prevention feature state
        """
        return self.get_policy_setting_value(self.main, 'bopStatus', 'bopUseGPEPEnabled')

    def set_gpep(self, state):
        """
        Set the Generic Priviledge Escalation Prevention feature state
        """
        return self.set_policy_setting_value(self.main, 'bopStatus', 'bopUseGPEPEnabled', state)

    gpep = property(get_gpep, set_gpep)

    # ------------------------------ Exploit Prevention Policy ------------------------------
    # Windows Data Execution Prevention:
    #   Enable Windows Data Execution Prevention
    def get_dep(self):
        """
        Get the Windows Data Execution Prevention use state
        """
        return self.get_policy_setting_value(self.main, 'bopStatus', 'bopUseDEPEnabled')

    def set_dep(self, state):
        """
        Set the Windows Data Execution Prevention use state
        """
        return self.set_policy_setting_value(self.main, 'bopStatus', 'bopUseDEPEnabled', state)

    dep = property(get_dep, set_dep)

    # ------------------------------ Exploit Prevention Policy ------------------------------
    # Network Intrusion Prevention:
    #   Enable Network Intrusion Prevention
    def get_nips(self):
        """
        Get the Network Intrusion Prevention feature state
        """
        return self.get_policy_setting_value(self.main, 'bopStatus', 'bopUseNIPSEnabled')

    def set_nips(self, state):
        """
        Set the Network Intrusion Prevention feature state
        """
        return self.set_policy_setting_value(self.main, 'bopStatus', 'bopUseNIPSEnabled', state)

    nips = property(get_nips, set_nips)

    # Network Intrusion Prevention:
    #   Automatically block network intruders
    def get_nips_auto_block(self):
        """
        Get the Automatically block network intruders feature state
        """
        result = self.get_policy_setting_value(self.main, 'bopStatus', 'bopNIPSHostBlockTime')
        return result if result == '0' else '1'

    def set_nips_auto_block(self, state):
        """
        Set the Automatically block network intruders feature state
        """
        result = self.get_policy_setting_value(self.main, 'bopStatus', 'bopNIPSHostBlockTime')
        return self.set_policy_setting_value(self.main, 'bopStatus', 'bopNIPSHostBlockTime', state) if int(result) >= 1 else True

    nips_auto_block = property(get_nips_auto_block, set_nips_auto_block)

    # Network Intrusion Prevention:
    #   Number of seconds (1-9999) to block
    def get_nips_block_time(self):
        """
        Get the Number of seconds to block network intruders
        """
        result = self.get_policy_setting_value(self.main, 'bopStatus', 'bopNIPSHostBlockTime')
        return int(result) if result is not None else 0

    def set_nips_block_time(self, int_seconds):
        """
        Set the number of seconds (1-9999) to block network intruders
        """
        if int_seconds < 1 or int_seconds > 9999:
            raise ValueError('It is not possible to set a block time over 9999 seconds.')
        return self.set_policy_setting_value(self.main, 'bopStatus', 'bopNIPSHostBlockTime', str(int_seconds))

    nips_block_time = property(get_nips_block_time, set_nips_block_time)

    # ------------------------------ Exploit Prevention Policy ------------------------------
    # Exclusions:
    # Default columns are as following:
    #   -> Type, Process Name, Caller Module Name, API Name, Signatures IDs, Service Name, IP Addresses
    #
    #  TO BE IMPLEMENTED

    # ------------------------------ Exploit Prevention Policy ------------------------------
    # Signatures:
    # It's not possible to modify ID 9950
    #   -> Microsoft DEP integration and monitoring by Endpoint Security
    #   -> User must enable Windows Data Execution Prevention
    # Default columns are as following:
    #   -> ID, Name, Severity, Block, Report, Status, Type, Origin, OS
    #
    #  TO BE IMPLEMENTED
    def signatures_list(self, mode='Used'):
        """
        Return a table in Markdown format
        Filter = Used, Unused, ExpertRules, All
        """
        types = { 'Buffer_Overflow': 'Buffer Overflow',
                  'Illegal_API_Use': 'Illegal API Use',
                  'ENS_Files': 'Files',
                  'Services': 'Services',
                  'ENS_Registry': 'Registry',
                  'ENS_Process': 'Processess',
                  'nips': 'Network IPS'
                }
        sev = ['Disabled', 'Informational', 'Low', 'Medium', 'High']
        txt = ''
        for sig in sorted(self.eprules.items(), key=lambda x: x[1]['SignatureID'], reverse=True):
            txt += sig[1]['SignatureID'] + '\t'
            txt += sig[1]['SignatureName'] + '\t'
            txt += sev[int(sig[1]['SignatureSeverity'])] + '\t'
            en = False
            if sig[1]['Block'] == '1':
                en = True
                txt += '[X]\t'
            else:
                txt += '[ ]\t'
            if sig[1]['Report'] == '1':
                en = True
                txt += '[X]\t'
            else:
                txt += '[ ]\t'
            if en:
                txt += 'Enabled\t'
            else:
                txt += 'Disabled\t'
            txt += types[sig[1]['SignatureClass']] + '\t'
            txt += 'User-Defined\t'
            txt += 'Windows' + '\r\n'
        return txt

    def signatures_contains_id(self, sig_id):
        """
        Return True if a signature exist based on SignatureID
        """
        result = self.__get_signature('SignatureID', sig_id) is not None
        if len(self.eprules) > 0:
            result = result or self.__get_eprule('SignatureID', sig_id) is not None
        return result

    def signatures_contains_name(self, sig_name):
        """
        Return True if a signature exist based on SignatureName
        """
        result = self.__get_signature('SignatureName', sig_name) is not None
        if len(self.eprules) > 0:
            result = result or self.__get_eprule('SignatureName', sig_name) is not None
        return result

    # It's not possible to modify ID 9950:
    #   -> Microsoft DEP integration and monitoring by Endpoint Security
    #   -> User must enable Windows Data Execution Prevention instead
    def get_signatures_block(self, sig_id):
        """
        Get the Block status of a signature
        """
        result = None
        if sig_id == '9950':
            return result
        key = self.__get_signature('SignatureID', sig_id)
        if key is not None:
            result = self.get_policy_setting_value(key, 'EXPRule', 'Block')
        elif len(self.eprules) > 0:
            key = self.__get_eprule('SignatureID', sig_id)
            if key is not None:
                result = self.get_policy_setting_value(key, 'EXPExpertRule', 'Block')
        return result

    def set_signatures_block(self, sig_id, state):
        """
        Set the Block status of a signature
        """
        result = False
        if sig_id == '9950':
            return result
        key = self.__get_signature('SignatureID', sig_id)
        if key is not None:
            result = self.set_policy_setting_value(key, 'EXPRule', 'Block', state)
            self.signatures[key]['Block'] = state
        elif len(self.eprules) > 0:
            key = self.__get_eprule('SignatureID', sig_id)
            if key is not None:
                result = self.set_policy_setting_value(key, 'EXPExpertRule', 'Block', state)
                self.eprules[key]['Block'] = state
        return result

    # It's not possible to modify ID 9950:
    #   -> Microsoft DEP integration and monitoring by Endpoint Security
    #   -> User must enable Windows Data Execution Prevention option instead
    def get_signatures_report(self, sig_id):
        """
        Get the Report status of a signature
        """
        result = None
        if sig_id == '9950':
            return result
        key = self.__get_signature('SignatureID', sig_id)
        if key is not None:
            result = self.get_policy_setting_value(key, 'EXPRule', 'Report')
        elif len(self.eprules) > 0:
            key = self.__get_eprule('SignatureID', sig_id)
            if key is not None:
                result = self.get_policy_setting_value(key, 'EXPExpertRule', 'Report')
        return result

    def set_signatures_report(self, sig_id, state):
        """
        Set the Report status of a signature
        """
        result = False
        if sig_id == '9950':
            return result
        key = self.__get_signature('SignatureID', sig_id)
        if key is not None:
            result = self.set_policy_setting_value(key, 'EXPRule', 'Report', state)
            self.signatures[key]['Report'] = state
        elif len(self.eprules) > 0:
            key = self.__get_eprule('SignatureID', sig_id)
            if key is not None:
                result = self.set_policy_setting_value(key, 'EXPExpertRule', 'Report', state)
                self.eprules[key]['Report'] = state
        return result

    # Add Expert Rule
    #   To add a new rule we need to collect and build the following information
    #       Block                   -> By default it's disabled
    #       Report                  -> By default it's disabled
    #       SignatureClass          -> Must be defined based on the rul_type
    #                                   -Buffer Overflow:   -> Buffer_Overflow
    #                                   -Illegal API Use:   -> Illegal_API_Use
    #                                   -Files:             -> ENS_Files
    #                                   -Services:          -> Services
    #                                   -Registry:          -> ENS_Registry
    #                                   -Processes:         -> ENS_Process
    #       SignatureContent#0001   -> The base64 encoded string value of rule
    #       SignatureDateModified   -> The date like this "janv. 22,2021 20:52:21 GMT+0000 "
    #       SignatureID             -> An incremental value upper 20000
    #       SignatureName           -> The name of the signature (can contain spaces)
    #       SignatureNodeCount      -> We will keep it simple and always equal to '1'
    #       SignatureNotes          -> The notes for the signature (blank per default)
    #       SignatureSeverity       -> Must be defined based on the severity
    #                                   -Informational, Low, Medium, High -> 1, 2, 3, 4
    def signatures_add(self, name, severity, block, report, rul_type, rule, notes=''):
        """
        Add an Expert Rule

        :param name: The Name of the rule

        :param severity: A value between '1', '2', '3', '4'

        :param rul_type: Buffer Overflow, Illegal API Use, Files, Services, Registry, Processes

        :param rule: The rule content in TCL

        :param notes: The rule notes
        """
        props = dict()
        # Define setting Block
        if block not in ['0', '1']:
            raise ValueError('Block must be "0" or "1".')
        props['Block'] = block
        # Define setting Report
        if report not in ['0', '1']:
            raise ValueError('Report must be "0" or "1".')
        props['Report'] = report
        # Define setting SignatureClass
        types = { 'Buffer Overflow': 'Buffer_Overflow',
                  'Illegal API Use': 'Illegal_API_Use',
                  'Files': 'ENS_Files',
                  'Services': 'Services',
                  'Registry': 'ENS_Registry',
                  'Processes': 'ENS_Process'
                }
        if rul_type not in list(types.keys()):
            raise ValueError('Rule type must be within {}.'.format(list(types.keys())))
        props['SignatureClass'] = types[rul_type]
        # Define setting SignatureContent
        props['SignatureContent#0001'] = b64.b64encode(rule.encode()).decode()
        # Define setting SignatureDateModified
        dt_obj = dt.datetime.now(dt.timezone.utc)
        props['SignatureDateModified'] = dt_obj.strftime('%b %d,%Y %H:%M:%S %Z%z')
        # Define setting SignatureID
        props['SignatureID'] = self.__get_signature_id()
        # Define setting SignatureName
        if len(name) < 1 or len(name) > 260:
            raise ValueError('The signature name must be defined with 260 caracters max.')
        props['SignatureName'] = name
        # Define setting SignatureNodeCount
        props['SignatureNodeCount'] = '1'
        # Define setting SignatureNotes
        if len(notes) < 1 and len(notes) > 256:
            raise ValueError('The notes must be defined with 256 caracters max.')
        props['SignatureNotes'] = notes
        # Define setting SignatureSeverity
        if severity not in ['0', '1', '2', '3', '4']:
            raise ValueError('Severity level must be within ["0", "1", "2", "3", "4"].')
        props['SignatureSeverity'] = severity
        # All settings are defined corectly, we need to build a new PolicySetting
        uid = str(uuid.uuid4()).upper()
        key = '{}::Settings ({})'.format(self.get_name(), uid)
        fid = 'ENDP_AM_1000'
        cid = 'EAM_BufferOverflow_Policies'
        # Add a new XML element EPOPolicySettings and section for EXPExpertRule
        setting_obj = et.SubElement(self.root, 'EPOPolicySettings',
                                    {"name":key, "featureid":fid, "categoryid":cid,
                                    "typeid":cid, "param_int":'0', "param_str":''})
        section_obj = et.SubElement(setting_obj, 'Section', {"name":'EXPExpertRule'})
        # Add all settings associated with the new rule
        for prop in props:
            et.SubElement(section_obj, 'Setting', {"name":prop, "value":props[prop]})
        # Add the new PolicySettings in the EPOPolicyObject
        policy_obj = self.root.find('./EPOPolicyObject')
        policy_set = et.SubElement(policy_obj, 'PolicySettings')
        policy_set.text = key
        # Add this new rule in memory to avoid a reload of the policy
        self.eprules[key] = props
        return True

    def signatures_delete(self, sig_id):
        """
        Remove an Expert Rule based on SignatureID
        """
        print('# TO BE IMPLEMENTED')
        return True

    # ------------------------------ Exploit Prevention Policy ------------------------------
    # Application Protection Rules:
    # Default columns are as following:
    #   -> Name, Status, Inclusion Status, Executables, Changed, Notes, Origin
    #
    #  TO BE IMPLEMENTED
